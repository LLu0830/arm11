%++++++++++++++++++++++++++++++++++++++++
% Don't modify this section unless you know what you're doing!
\documentclass[letterpaper,11pt]{article}
\usepackage{tabularx} % extra features for tabular environment
\usepackage{amsmath}  % improve math presentation
\usepackage{graphicx} % takes care of graphic including machinery
\usepackage[margin=1in,letterpaper]{geometry} % decreases margins
\usepackage{cite} % takes care of citations
\usepackage[final]{hyperref} % adds hyper links inside the generated pdf file
\usepackage{dirtytalk}
\usepackage{textcomp}
\hypersetup{
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=blue,        % color of internal links
citecolor=blue,        % color of links to bibliography
filecolor=magenta,     % color of file links
urlcolor=blue
}
%++++++++++++++++++++++++++++++++++++++++


\begin{document}

    \title{\textbf{Final Report}}
    \author{C Group 31\\* Rini Banerjee (rb3018), Katarina Kulkova (kk6418),\\* Lize Lu (ll7818), Manshu Wang (mw6118)}
    \date{June 2019}
    \maketitle

    \section{Project Structure}
    \subsection{Part I - The Emulator}
    For details on how we structured Part I, please see our Checkpoint Report.

    \subsection{Part II - The Assembler}
    \noindent{In a similar style to that of our emulator, we have divided our assembler into five directories: \* \textit{assembler\_utility}, \textit{encode}, \textit{readInstruction}, \textit{readLabels} and \textit{tokenizer}. The \texttt{assemble.c} file (which contains the main function for Part II) is outside the directories, and all of the aforementioned directories and files are inside the \textit{part2\_emulator} directory in \textit{src}.\\*
    }

    \noindent Here is a brief synopsis of how we structured each directory:

    \begin{itemize}
        \item \textit{assembler\_utility}: includes \texttt{assembler\_utility.c}, \textt{table.c} and corresponding header files. \texttt{assembler\_utility.c} contains utility functions that we need for the assembler specifically - they had not been written in Part I\textquotesingle s \texttt{utility.c} because we wrote them after finishing Part I. \texttt{table.c} includes functions that are needed for creating and accessing elements of the symbol table, while \texttt{table.h} contains enums and typedef structs we created specifically for Part II - e.g., the typedef struct assembler\_instruction, which represents an instruction in assembly code
        \item \textit{readInstruction}: includes \texttt{readInstruction.c} and a corresponding header file. The function readInstruction in \texttt{readInstruction.c} reads one instruction at a time from the file that is passed in as a parameter, and passes this instruction to the tokenizer (see below). If the instruction cannot be read (e.g., if the file pointer is null or the file is empty), the function returns false; otherwise, it returns true
        \item \textit{readLabels}: includes \texttt{readLabels.c} and a corresponding header file. The function readLabels reads labels and their corresponding addresses from the file that is passed in as a parameter, one label-address pair at a time, and stores them in the symbol table
        \item \textit{tokenizer}: includes \texttt{tokenizer.c} and a corresponding header file. The function tokenizer in \texttt{tokenizer.c} takes an instruction string (char *), parses it to separate it into its mnemonic and arguments and then stores these values in an assembler\_instruction
        \item \textit{encode}: includes \texttt{encode.c}, \texttt{encodeBR.c}, \texttt{encodeDP.c}, \texttt{encodeMUL.c}, \texttt{encodeSDT.c}, \\* \texttt{encodeSPECIAL.c} and corresponding header files. Every \texttt{.c} file other than \texttt{encode.c} contains a function of the same name which performs the encoding for that type of instruction. The function encode in \texttt{encode.c} turns an assembler instruction into its binary representation. Depending on which mnemonic an instruction has been assigned by the tokenizer in \texttt{tokenizer.c}, the operation type and instruction type are assigned to the instruction using enums defined previously in \texttt{table.h} and \texttt{DefinedTypes.h} (the latter header file being from Part I). Then, depending on the operation type, one of encodeDP (Data Processing), encodeMUL (Multiply), encodeSDT (Single Data Transfer), encodeBR (Branch) and encodeSPECIAL (Special) is called, returning the encoded binary instruction

    \end{itemize}

    \subsection{Part III - General Purpose Input/Output on a Raspberry Pi}
    Our assembly program for Part III is in the file gpio.s, inside the programs directory. It contains a main loop for switching the LED on and off infinitely many times (\textit{LED\_loop}), as well as delay loops for pausing the LED for a few seconds while the LED is on and off.
    \subsection{Part IV - The Extension}

    For the extension, we built a 3 bits binary machine, which uses the Raspberry Pi and three LEDs. There are 3 modes of the main program: the binary counter, the presenter and the calculator. One LED will blink different times to present which mode the machine is on.\\*

    \noindent The first mode is the binary counter, which causes the LEDs to light up a few times in order to count through the decimal integers from 0 to the number the user entered. The highest number that can be represented in binary by three bits is 7, so this is the maximum user input. Each LED lights up for 0.8 seconds, and switches off for 0.2 seconds before lighting up again. Therefore, since there is a 1 second time interval between each time the LED lights up, the first mode can also be used as a clock. \\*

    \noindent The second mode is a presenter, which requires one decimal integer input from the user. The program causes the LEDs to light up in a way that represents the user input. \\*

    \noindent The third mode is a calculator which presents the result using the LEDs. It requires three inputs: the first two are integer inputs (in either decimal or binary form), and the third is the type of arithmetic operation the user wants to perform on the two integers. The LEDs present the result of this arithmetic operation.

    \subsubsection{Implementation}
    Part IV was divided into four directories: \textit{counter}, \textit{presenter}, \textit{calculator} and \textit{part4\_utility}. The \texttt{machine.c} file which contains the main function for Part 4 is outside those directories. All the directories are included in part4\_extension directory inside src.\\*

    \noindent Here is a brief synopsis of how we structured each directory:

    \begin{itemize}
        \item \textit{part4\_utility}: contains \texttt{part4\_utility.c}, \textttt{shine.c} and the corresponding header files.
        \begin{itemize}
            \item \texttt{part4\_utility.c} contains the functions bin2dec and dec2bin, which convert a binary number to decimal form and vice versa. It also contains two bool functions. The first one is isValid, which checks if the number is in the range 0 - 7, and this is needed to ensure that the LEDs can represent the user input. The second bool function is isBin, which checks if a number is in binary form. There is also a function called operate\_arith in this file, which does the calculation for mode 3 of the binary machine (the calculator)

            \item \texttt{shine.c} contains the functions shine and mode\_LED. We included the Pi library \\* \texttt{<WiringPi.h>} in the function shine to manipulate the GPIO pins (defining a pin as an input, an output and clearing it to reset it); this allowed us to switch the three LEDs on and off according to the binary input. WiringPi pins 0, 1 and 2 were mapped to BCM\_GPIO pins 17, 18 and 21 respectively. mode\_LED makes one of the LEDs blink 1, 2 or 3 times to indicate which mode the machine is in. mode\_LED is called in the main function.
        \end{itemize}

        \item \textit{counter}: includes \texttt{counter.c} and the corresponding header file. It represents the first mode of the binary machine.
        \begin{itemize}
            \item \texttt{counter.c} includes the function counter, which prints out instructions for the user and calls the helper function counter\_helper.  counter\_helper loops through the decimal numbers from 1 to the number entered and causes the LEDs to shine accordingly (using the function shine from part4\_utility). The LEDs blink at most 8 times in a call to counter.
        \end{itemize}
        \item \textit{presenter}: includes \texttt{presenter.c} and the corresponding header file. It represents the second mode of the binary machine.
        \begin{itemize}
            \item \texttt{presenter.c} includes the presenter function. It prints out instructions for the user and takes in a decimal number from user; it then presents it using the LEDs. presenter calls the function dec2bin, which converts the decimal number to binary form, and then calls the function shine to control the LEDs.
        \end{itemize}
        \item \textit{calculator}: includes \texttt{calculator.c} and the corresponding header file. It represents the third mode of the binary machine.
        \begin{itemize}
            \item \texttt{calculator.c} includes the function calculator.  It prints out instructions for the user and takes in two integers (either in binary or decimal form) and a string representing the operation type from the user. It then presents the arithmetic result using the LEDs. calculator converts the binary input to decimal form and calls the function operate\_arith to compute the result. It then calls the function shine to control the LEDs to represent the result.
        \end{itemize}
    \end{itemize}

    \noindent \texttt{machine.c} contains the main function, which prints the instruction telling the user to input an integer to choose a mode. It then switches on the input and calls mode\_LED and the corresponding mode function.


    \section{Testing our implementation}
    The majority of our testing for Parts I and II was done using the provided test suite. This proved to be helpful

    \section{Reflecting on the project}
    \subsection{Group reflection}
    \subsection{Individual reflections}
    \subsubsection{Rini}
    \subsubsection{Katarina}
    My personal experience working in this group has been a positive one. Besides some minor issues that we managed to overcome, our group was working together quite well.\\*

    \noindent While working on the first part of the project, we did not split the work in an optimal way, which often resulted in merge conflicts. We learned from that, however, and we organised our work significantly better in the subsequent parts of the project. Good organisation and planning is something I would definitely want to see in any future projects I have to take part in, as it can facilitate the given task and it is very good to avoid confusion. This project has helped me achieve a better understanding on how to work in a group.\\*

    \noindent In my opinion, our group was well balanced and everyone, despite having different strengths and weaknesses, was on a similar ability level, which means I fitted in the group well. I also greatly appreciated the fact that we were communicating with each other on a regular basis, and the communication was carried out effectively, which meant we could promptly discuss and subsequently resolve most problems that arose during the time we were working on the project. Although I had some doubts about my own abilities, as I have never done C before,  and thus was worried that my contribution to the project may not on par with the standards required, my doubts were dispelled after I started working and the encouraging and friendly working environment maintained in our group was especially helpful in getting me started and gaining more confidence in myself. I am especially glad that I managed to maintain a strong work ethic while working on this project, as did everyone in our group, for that matter.\\*

    \noindent The most significant problems I personally encountered were related to the fact that I had no prior experience with C and found the beginning quite challenging. One unforeseen issue was that the IDE on my laptop was only displaying some of the warnings it should have, despite my attempts to fix the problem, so debugging on my laptop took more time than on a different machine. Despite all the challenges, I had a very positive experience working on this project and with this particular group of people.

    \subsubsection{Lize}
    The cooperation in this project was sound and every group member worked very hard and fitted in well. All the group members were on the same ability level and the communication we made was efficient. Due to the lack of experience of using git, we encountered a lot of merge conflicts at the beginning. However, we learned our lesson and the remaining part of the project was done in a way better-organized way. The optimized plan we made enabled me to make up for my weakness by practising in the process and extended our strengths on some level.\\*

    \noindent I had no experience with C language before, so I tended to demand more time writing correct code and debugging, which was definitely a weakness. However, just like other group members, I was very willing to spend more time reading the spec and working on the project. A positive working attitude is what I can think of as a strength of mine. To make up for my weakness, my original thought was simply to spend more time working on the project in order to finish my part in time.\\*

    \noindent The plan we made after finishing part 1 was Rini and Manshu kept debugging to pass tests. I did not do much of the debugging work which I am not good at, instead, Katarina and I started figuring out the general structure and schema of part 2 and started working on it. After two weeks of struggling during the process of finishing part 1 and part 2, my programming and debugging skills enhanced, which means my weakness was made up to some extent. I was able to code and debug the extension part by the end of the project.\\*

    \noindent Before starting working in the group, I was worried about my limited ability and lack of communication among members. It turned out the sound working atmosphere among our group members dispelled my concerns, everyone was hard-working and we encouraged each other while struggling at some point of the project. The project was done in a well-organized way and it was a true pleasure working in this group.\\*

    \subsubsection{Manshu}
    For our group, I think our weakness is that we are about same level of programming and that none of us knew C before this semester. That was the thing I worried most but now I think this is also one of the advantages. Since the purpose of this project is to handle C programming language well instead of just an excellent outcome. I feel like we did really well on that as we learnt and progressed together during practices, and we all spent lots of time working on this project. We always explain to others what we did and how we did it, so all of us know how the program works well. If I were in a different group, with some experts in C programming, I won’t actually make such a huge progress and I won’t be so joyful when we pass all the test cases.\\*

    \noindent How to start working on a project is always the hardest thing. The basic structure was the key of the whole project but quite confusing to me when first time reading the spec. I did go through the spec quite a few times reading every sentence carefully and asked help from mentors and UTAs. After building a nice structure, everything worked out well.\\*

    \noindent I really feel a comfortable atmosphere working in such a group, all the group members are positive, encouraging and hard-working. And of course, we followed our schedule, all of us were able to finish our work by the deadline we\textquotesingle ve set, also help each other. Besides, we split our parts efficiently and so everyone is doing some work all the time.



\end{document}